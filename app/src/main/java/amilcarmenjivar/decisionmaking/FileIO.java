package amilcarmenjivar.decisionmaking;

import android.content.Context;
import android.os.Environment;
import android.util.Log;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import amilcarmenjivar.decisionmaking.data.DataManager;
import amilcarmenjivar.decisionmaking.data.Instance;
import amilcarmenjivar.decisionmaking.data.Result;

/**
 *
 * Created by Amilcar Menjivar on 30/04/2015.
 */
public class FileIO {

    public static final String TEMP_FILE_NAME = "tempFile.csv";
    public static final String SAVE_DIRECTORY = "DecisionMaking";

    public static final String APP_SIGNATURE = "Generated by DecisionMaker";

    // TODO: Failsafes: nCandidates <= 2, nAttributes <= 2, nProfiles < 1, nJudges < 1


    // TODO: remove after testing
    private static boolean useTestInstances = false;

    public static String[] listFiles() {
        if(useTestInstances) {
            return new String[] { "Instance 1", "Instance 2", "Instance 3" };
        }

        File directory = getSaveDirectory();
        File[] files = directory.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String filename) {
                return filename.endsWith(".csv");
            }
        });

        // List instance title
        List<String> instanceNames = new ArrayList<String>();
        for(File file : files) {
            if(isValidFile(file)) {
                String fileName = file.getName().replace(".csv", "");
                instanceNames.add(fileName);
            }
        }

        return instanceNames.toArray(new String[instanceNames.size()]);
    }

    private static boolean isValidFile(File file) {
        if(file != null && file.exists()) {
            try{
                BufferedReader br = new BufferedReader(new FileReader(file));
                String firstLine = br.readLine();
                br.close();
                return firstLine != null && firstLine.startsWith(APP_SIGNATURE);
            }catch(IOException e){
                Log.wtf("DecisionMaking", "Problems reading file: "+file.getName(), e);
            }
        }
        return false;
    }

    public static boolean isExternalStorageWritable() {
        String state = Environment.getExternalStorageState();
        return Environment.MEDIA_MOUNTED.equals(state);
    }

    public static Instance importFromFile(File file) {
        if(file == null || !file.exists()) {
            return null;
        }
        try {
            BufferedReader br = new BufferedReader(new FileReader(file));

            String firstLine = br.readLine();
            if(firstLine == null || !firstLine.startsWith(APP_SIGNATURE)) {
                return null;
            }

            // Read the candidates, attributes, profiles and judges.
            List<String> candidates = readList(br);
            List<String> attributes = readList(br);
            List<String> profiles = readList(br);
            List<String> judges = readList(br);
            br.readLine();

            int cPairs = candidates.size() * (candidates.size()-1) / 2;
            int aPairs = attributes.size() * (attributes.size()-1) / 2;

            // Read Attributes info
            int[][][] attributeInfo = readRawDataMatrices(br, attributes.size(), cPairs, judges.size());
            br.readLine();

            // Read Profiles info
            int[][][] profileInfo = readRawDataMatrices(br, profiles.size(), aPairs, judges.size());

                // Ignore the rest.
            return Instance.newInstance(candidates, attributes, profiles, judges, attributeInfo, profileInfo);
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    public static void saveTempFile(File file) {
        exportResultToFile(null, file);
    }

    public static boolean exportInstanceToFile(Instance instance, String fileName) {
        File directory = getSaveDirectory();
        File file = new File(directory, fileName);
        Result result = instance == null ? null : instance.getResult();
        if(result != null) {
            exportResultToFile(result, file);
            return file.exists();
        }
        return false;
    }

    // TODO: the table names on the export file should be localized

    private static void exportResultToFile(Result result, File file) {
        BufferedWriter bw;
        try {
            bw = new BufferedWriter(new FileWriter(file));
            List<String> candidates = DataManager.getCandidates();
            List<String> attributes = DataManager.getAttributes();
            List<String> profiles = DataManager.getProfiles();
            List<String> judges = DataManager.getJudges();

            bw.write(APP_SIGNATURE+"\n");

            // Write the candidates, attributes, profiles and judges.
            printList(bw, candidates);
            printList(bw, attributes);
            printList(bw, profiles);
            printList(bw, judges);
            bw.newLine();

            // Write raw comparison data for attributes
            int[][][] attributeInfo = result == null ? DataManager.getAttributeData().getRawData() : result.attributeInfo;
            writeRawDataMatrices(bw, attributeInfo);
            bw.newLine();

            // Write raw comparison data for profiles
            int[][][] profileInfo = result == null ? DataManager.getProfileData().getRawData() : result.profileInfo;
            writeRawDataMatrices(bw, profileInfo);
            bw.newLine();

            if(result != null) {
                // Write comparison data for attributes
                List<String> cPairs = makePairs(candidates);
                bw.write("Attributes Comparison\n");
                writeComparisonMatrices(bw, result.mcaj, result.mvca, attributes, cPairs, judges);
                bw.newLine();

                // Write comparison data for profiles
                List<String> aPairs = makePairs(attributes);
                bw.write("Profiles Comparison\n");
                writeComparisonMatrices(bw, result.mcpj, result.mvcp, profiles, aPairs, judges);
                bw.newLine();

                // Write preference matrix for attributes
                bw.write("Preferences Matrices (per Attribute)\n");
                writePreferenceMatrices(bw, result.mmpa, attributes, candidates);
                bw.newLine();

                // Write preference matrix for profiles
                bw.write("Preferences Matrices (per Profile)\n");
                writePreferenceMatrices(bw, result.mmpp, profiles, attributes);
                bw.newLine();

                bw.newLine();

                // Write Candidates X Attributes matrix
                bw.write("Attributes Matrix\n");
                writeMatrix(bw, result.attributesMatrix, "Attributes", candidates, attributes);
                bw.newLine();

                // Write Attributes X Profiles matrix
                bw.write("Profiles Matrix\n");
                writeMatrix(bw, result.profilesMatrix, "Profiles", attributes, profiles);
                bw.newLine();

                // Write Result Candidates X Profiles matrix
                bw.write("Results Matrix\n");
                writeMatrix(bw, result.resultMatrix, "Results", candidates, profiles);
            }

            bw.flush();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
            Log.wtf("FuckingApp", "IOEx When writing file.", e);
        }
    }

    public static boolean isTempFileFound(Context context) {
        File file = new File(context.getFilesDir(), FileIO.TEMP_FILE_NAME);
        // TODO: check if it is valid!
        return file.exists();
    }

    private static List<String> makePairs(List<String> elements) {
        List<String> pairs = new ArrayList<String>();
        String[] array = elements.toArray(new String[elements.size()]);
        for(int i=0; i<array.length-1; i++) {
            for(int e=i+1; e<array.length; e++) {
                String pair = array[i] +" vs "+ array[e];
                pairs.add(pair);
            }
        }
        return pairs;
    }

    private static List<String> readList(BufferedReader br) throws IOException {
        String[] line = br.readLine().split(",");
        int size = Integer.parseInt(line[0]);

        List<String> list = new ArrayList<String>();
        list.addAll(Arrays.asList(line).subList(1, size + 1));
        return list;
    }

    private static void printList(BufferedWriter bw, List<String> list) throws IOException {
        int size = list.size();
        StringBuilder builder = new StringBuilder();
        builder.append(size);
        for(String s : list) {
            builder.append(",");
            builder.append(s);
        }
        builder.append("\n");
        bw.write(builder.toString());
    }

    private static int[][][] readRawDataMatrices(BufferedReader br, int nCriteria, int nPairs, int nJudges) throws IOException {
        // Read quantities from first line
        int[][][] data = new int[nCriteria][nPairs][nJudges];

        for(int c=0; c<nCriteria; c++) {
            for(int p=0; p<nPairs; p++) {
                String[] line = br.readLine().split(",");
                for(int j=0; j<nJudges; j++) { // any thrown AIOB exception implies a corrupted file.
                    int val = 0; // 0 means not found
                    try{
                        val = Integer.parseInt(line[j]);
                    } catch(NumberFormatException e) {
                        Log.e("FileIO", String.format("Wrong format at raw data (%s,%s,%s)", c, p, j));
                    }
                    data[c][p][j] = val;
                }
            }
        }
        return data;
    }

    private static void writeRawDataMatrices(BufferedWriter bw, int[][][] matrix) throws IOException {
        int nCriteria = matrix.length;

        // Write a matrix (nPairs*nJudges) per each criteria.
        for(int c=0; c<nCriteria; c++) {
            for(int p=0; p<matrix[c].length; p++){
                StringBuilder s = new StringBuilder();
                for(int j=0; j<matrix[c][p].length; j++) {
                    if(j>0) s.append(",");
                    s.append(Integer.toString(matrix[c][p][j]));
                }
                s.append("\n");
                bw.write(s.toString());
            }
        }
    }

    private static void writeComparisonMatrices(BufferedWriter bw, double[][][] matrix, double[][] vector, List<String> criteria, List<String> pairs, List<String> judges) throws IOException {
        int nCriteria = criteria.size();
        int nPairs = pairs.size();
        int nJudges = judges.size();

        // Write a matrix (nPairs*nJudges) per each criteria.
        for(int c=0; c<nCriteria; c++) {
            // Headers
            StringBuilder header = new StringBuilder();
            header.append(criteria.get(c));
            for(String judge : judges) {
                header.append(",").append(judge);
            }
            bw.write(header.toString() + "\n");

            for(int p=0; p<nPairs; p++){
                StringBuilder s = new StringBuilder();
                s.append(pairs.get(p)); // Pair
                for(int j=0; j<nJudges; j++) {
                    s.append(",");
                    s.append(Double.toString(matrix[c][p][j]));
                }
                s.append(",");
                s.append(",");
                s.append(Double.toString(vector[c][p])); // geomean
                s.append("\n");
                bw.write(s.toString());
            }
            bw.newLine();
        }
    }

    private static void writePreferenceMatrices(BufferedWriter bw, double[][][] matrix, List<String> criteria, List<String> elements) throws IOException {
        int nCriteria = criteria.size();
        int nElements = elements.size();

        // Write a matrix (nPairs*nJudges) per each criteria.
        for(int c=0; c<nCriteria; c++) {
            // Headers
            StringBuilder header = new StringBuilder();
            header.append(criteria.get(c));
            for(String element : elements) {
                header.append(",").append(element);
            }
            bw.write(header.toString() + "\n");

            for(int i=0; i<nElements; i++){
                StringBuilder s = new StringBuilder();
                s.append(elements.get(i));
                for(int j=0; j<nElements; j++) {
                    s.append(",");
                    s.append(Double.toString(matrix[c][i][j]));
                }
                s.append("\n");
                bw.write(s.toString());
            }
            bw.newLine();
        }
    }

    private static void writeMatrix(BufferedWriter bw, double[][] matrix, String title, List<String> rows, List<String> columns) throws IOException {
        // Headers
        StringBuilder header = new StringBuilder();
        header.append(title);
        for(String element : columns) {
            header.append(",").append(element);
        }
        bw.write(header.toString() + "\n");

        Log.wtf("FuckingApp", "Rows: " + rows.size() +" Columns:"+columns.size());

        for(int i=0; i<rows.size(); i++){
            StringBuilder s = new StringBuilder();
            s.append(rows.get(i));
            for(int j=0; j<columns.size(); j++) {
                s.append(",");
                s.append(Double.toString(matrix[i][j]));
            }
            s.append("\n");
            bw.write(s.toString());
        }
    }

    public static File getTempFile(Context context) {
        return new File(context.getFilesDir(), FileIO.TEMP_FILE_NAME);
    }

    public static File getSaveDirectory() {
        String root = Environment.getExternalStorageDirectory().toString();
        File directory = new File(root, SAVE_DIRECTORY);
        if(!directory.exists()) {
            directory.mkdirs();
        }
        return directory;
    }
}
